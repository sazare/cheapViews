README

### cheaplogic prover
misc.jl       -- nyi() ... something like this

primitives.jl -- primitive difinitions and functions
utils.jl      -- basic concepts and readclause/readcore
reso.jl       -- resolution operations -- almost uncompatibles
newcore.jl    -- new core concepts
coreprint.jl  -- print over core
dvcreso.jl    -- DVC based resolution and more

setupdata.jl  -- just setup data 
play.jl       -- playgound

#tests
test_cheaplogic.jl -- run tests for cheaplogic
 testreso.jl
 testutils.jl
 testmerge.jl
 testnewcore.jl
 testdvcreso.jl
 testparser.jl
 testprover.jl

# data basic axiom sets
*.cnf       -- test sets cnf form

common.fun  -- executable literal definition which included by < in cnf
rundata.jl  -- run simpleprover() with all *.cnf
allconds.jl -- get all contradictions after rundata.jl
fol.syntax  -- fol syntax idea not filan
*.exp       -- fol format formula ideas

-- cnf format
first character's meaning
1) [    : a clause whole line
2) !    : a form except ! will be evaluated.
3) <    : a filename excpet < is readclausefromfile()'ed
4) o.w. : comment/no special meaning

you can browse by following one liner
 $ grep -H '^@ ' *.cnf  # first line with @ is an general meaning
 $ grep -H '^@@' *.cnf   # leftmost @@ means something technical information
 $ grep -H '^#' *.cnf    # # is used usual comments. this may be tedious
 $ grep -H '^<' *.cnf    # < means include other cnf
 $ grep -H '^<data/common.fun' *.cnf   # It may use executable literals.

For these grep effective, when write a cnf, follow the such style.

### spec for LPS
load_lps.jl : load lps 
spec/runspec.jl demo lps with some examples

### KP logic is keyword-parameter unification and resolution based on it.
kptype.jl
kpbase.jl

load_kplogic.jl
test_kplogic.jl -- run tests for KP logic

play_kp.jl : demo for print as Japanese from KP formula

