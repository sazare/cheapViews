KP logicの説明 20190321

[概要]
KP はkeyword predicateの略。
キーワードつきの引数で述語が書けるようにしたもの。
最初の動機は、日本語の助詞はキーワードとして書くのがよさそうに思えたから、
そのような述語で書いたAxiomsでの証明がどうなるかの実験のために実装した。


[仕様]
 1) キーワードが書けるのは述語の引数のみで、関数の引数には書けない。
 2) unifyする2つのリテラルの引数にはすべてキーワードが必要。
　　キーワードつきの引数と、キーワードなしの引数が混在する述語は書けない。
 3) unifyする2つのリテラルのキーワードが完全に一致している必要はない。
　　たとえば、P(a=x,b=y)とP(b=k,c=z)をunifyすると、<y:k>のみのmguになり、xやzについては無視する。

[補足]
1)については、助詞ができればよかったので、関数のキーワード引数までは不要と考えた。
　その上で、関数のキーワード引数までやると、cheaplogicで修正が多くなり、めんどうだと思ったから。
2) ここで言っているのは
  P(a=x, y) のような表現は許さないということであり、書くときは全部P(a=x, b=t)としてくれということ。
　キーワード引数をDictで実装するつもりだったので、キーワードのない引数の扱いがめんどうくさくなるだろうと考えた。そこまで深入りするつもりもなかったので、このようにした。
　また、clauseで[-P(a=x,b=y),+R(f(x), g(x,y))]のようなものもできない。
　1つのAxiomsでは、すべてキーワードつきか、そうでないかのどちらか。
　これを許すと、リテラルによってunify関数を切り替える必要があり、それがmethod dispatchでできないと
　かなりめんどうくさそうだったから。
  cheaplogicではExpr, kplogicではKPExprという型で切り分けるようにしようとしたが、現状、うまくできていない。つまり、リテラルは+/-のついたExprだが、この+/-のargsがKPExprであるようなものはExprではないので、やめた。+/-のついたKPExprを定義すればよさそうだが、これもまためんどうくさかった。
3) キーワードをつけているので、省略できることが期待され、それによってこのような仕様になった。
  Juliaのキーワード引数やCommonLispのキーワードつき引数など、プログラミング言語の場合は、値の受け渡しという処理をどうするかという問題になるが、この場合は、unificationの話。
　たぶん、キーワードつきの述語を実装したProverなどはあると思う。調べていない。

[コメント]
ことほどさように、めんどうくさいものはしない。やりたいこととめんどうくささのバランスが
やりたいことに+だったらやるが、そうでなければやらないという方針がcheaplogic。
おもしろい結果が得られそうなら(手で計算して想像する)、多少めんどうでもやる。
cheaplogic自体、めんどうくさいと思うが、作ったのはProverがおもしろいと思ったから。
[コメントおわり]


例1)日本語の助詞として使う
* 妹が怪我をしたので、会社を休む。
をKP Logicで表現すると
* [誰].[¬する(が=誰,を=怪我)⇒ 休む(が=妹, を=会社)]
のように表現できる。

kplogicだと、このようなclause表現になる
[who].[-する(ga=who,wo=怪我),+休む(ga=妹,wo=会社)]

助詞を忘れてキーワードの表現で何がかけるか・・・

例2) 日付の表現
* Date(year=2019,mon=3,day=21,week=Thu,type=holiday)
  Date(year=2019,mon=3,day=22,week=Fri,type=working)

  Date(year=2019,mon=3)
  Date(year=2019,mon=3,week=Sun)
などなど

このとき
  今年は、日曜には、公園にいく。は
  Date(year=2019, week=Sun)⇒ At(I, park)

　みたいなかんじ。
  (この例は、無限にかかわるのでおもしろいかも)
　強制的に公園に行かされるような雰囲気がある。

例3) システムのconfigの設定
* システムの定義に
  Config(mode1=true)⇒ System(mode1=true, ...)
  Config(mode1=false)⇒ System(mode1=false, ...)
と書いておいて、環境設定で、次のように書くとmode1のみ有効になるとか
* Config(mode1=true)

あるいは
  Config(mode1=true)⇒ System1(...)
  Config(mode1=false)⇒ System2(...)
と書くとか

あるいは
　Config(mode1=mode_setting)⇒ System(mode=mode_setting, ...)
と書いておいて、Systemの中で参照するとか、
  Systemの中で直接Configを参照するとか



[実装]
include("load_kplogic.jl")
で必要な関数がincludeされる。
例は、kpdataに作っていて、実行は
include("kpdata/runkpdata.jl")

* 追加したものは
 kptype.jl
 kpbase.jl
それ以外のkp*.jlはcheaplogicのソースの一部に手を加えたもの。
cheaplogicと共通な関数ははずしておけばよいが、していない。
もうすこしいろいろやったあとに考える。

 test_kplogic.jlがkplogic関連のすべてのテストを実行する。
とはいってもcheaplogicのについてはやっていないので、そこは不完全。


