方法
juliaを起動し、
include("load_naivelogic.jl")またはinclude("load_cheaplogic.jl")のあと
次を5回実行し、それぞれの実行時間を計測した。
初回はコンパイルがはしるので、2回目以降を比較する。

@time simpleprover("data/ml007.cnf",50,20)
元のデータの特徴
input clause数=23
input literal数=36
述語数 = 6


unit=seconds
naive logic         cheaplogic
3.010082            2.647374
1.781970            1.478603
1.773575            1.496474
1.806115            1.560623
1.798343            1.507890
1.885338            1.517728

cheapのほうが早いがその意味は??

simpleprover実行後の状態
- naivelogic
resolvent数=49-23=26
printcoreによると、resolvent数 = 37 になるのはなぜか?
#trial   = 69
#success = 26

- cheaplogic
resolvent数=34-23=11
resolvent数=11
#trial   = 49
#success = 11

naive: 1.813315 seconds (3.50 M allocations: 175.133 MiB, 1.90% gc time)
cheap: 1.517728 seconds (3.33 M allocations: 165.713 MiB, 2.27% gc time)

疑問点
・なぜcheapのほうがtrialやsuccessが少ないのか??
　まず、[]の含む情報が同じかどうかの確認が必要。

-  successの数は[]の数。usccessの数=resolventの数。

gc timeはcheaplogicのほうが多い

違うのと同じのがある
違うもの

rml002,cml002=simpleprover("data/ml002.cnf",5,2)  # evalon
rml003,cml003=simpleprover("data/ml003.cnf",5,2)  # evalon
rml004,cml004=simpleprover("data/ml004.cnf",5,2)  # evalon
rml005,cml005=simpleprover("data/ml005.cnf",5,2)  # evalon
rml006,cml006=simpleprover("data/ml006.cnf",6,2)  # evalon #1[] determined img3 battle. but no others.
rml007,cml007=simpleprover("data/ml007.cnf",50,20)  # evalon #5[] can't determin img3. 50 steps no effect. contralimit=20 needed
rml007a,cml007a=simpleprover("data/ml007a.cnf",50,20)  # evalon #5[] can't determin img3. 50 steps no effect. contralimit=20 needed
rml007b,cml007b=simpleprover("data/ml007b.cnf",50,20)  # evalon #5[] can't determin img3. 50 steps no effect. contralimit=20 needed
rml007c,cml007c=simpleprover("data/ml007c.cnf",50,20)  # evalon #5[] can't determin img3. 50 steps no effect. contralimit=20 needed
rml008,cml008=simpleprover("data/ml008.cnf",15,2)  # evalon
#rpprop001,cpprop001=simpleprover("data/pprop001.cnf",5,2)
rprob00,cprob00=simpleprover("data/prob00.cnf",5,2) # 2[] 2ways found
rprob01,cprob01=simpleprover("data/prob01.cnf",5,4) # intrinsic 3[]in 7  2ways found
rpar002,cpar002=simpleprover("data/par002.cnf",10,5)

resolventの数が多くて同じものもある。


不明点
original algorithmでは、
 unify([:x,:y],:(P(f(x),x)),:(P(y,a)))
 がちゃんと
 [  :a  ,   :(f(a))]
 になるのか??
あとで決まる代入(x:=a)が、先に求めた代入(y:=f(x))に
applyされるのか?? ということ
chang&leeで確認 
 
**** では同じ結果になるもので比較
[テスト方法]
1時には1つのjuliaを起動し、include("load_xxx")でそれぞれをloadして実行する	
両方ともにjulia起動直後に実行している。
@time rhave002,chave002=simpleprover("data/have002.cnf",7,1)	


	naivelogic	cheaplogic
1	3.461726 seconds (5.88 M allocations: 294.410 MiB, 4.24% gc time)	3.451440 seconds (6.10 M allocations: 304.360 MiB, 4.17% gc time)
2	0.032746 seconds (20.28 k allocations: 1.266 MiB)	0.030420 seconds (20.07 k allocations: 1.251 MiB)
3	0.035396 seconds (20.28 k allocations: 1.266 MiB)	0.033770 seconds (20.07 k allocations: 1.251 MiB)
4	0.033922 seconds (20.28 k allocations: 1.266 MiB)	0.034658 seconds (20.07 k allocations: 1.251 MiB)
5	0.035275 seconds (20.28 k allocations: 1.266 MiB)	0.054522 seconds (20.07 k allocations: 1.251 MiB, 12.93% gc time)
		
	trial=40; success=24	は両方同じ。

[比較]
あまり時間が変わらないが、cheapははやい。
5回目でcheapのほうが遅いのはgcがおきたからと思われる。
メモリの使用量もcheapのほうが少なめ。
cheapだけgcが起きているということは、メモリの使い方が違うから。
		
[処理の違いについて]
naiveは毎回全Exprについてsubstをくりかえす。cheapは
それはしないが、そのかわり余分なσ操作がはいっている。
合計すると、cheapのほうがやや速いということだろう。
メモリ使用量についてはdeepcopy()が関係するのかも"	
		
